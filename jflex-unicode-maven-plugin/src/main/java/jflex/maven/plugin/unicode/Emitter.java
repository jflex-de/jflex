package jflex.maven.plugin.unicode;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

public class Emitter {

  /** The name of the output file (without .java) and the contained class. */
  static final String OUTPUT_CLASS_NAME = "UnicodeProperties";

  private final File outputDirectory;

  /** Maps validated major.minor unicode versions to information about the version. */
  private SortedMap<String, UnicodeVersion> unicodeVersions = new TreeMap<>();

  public Emitter(File outputDirectory) {
    this.outputDirectory = outputDirectory;
  }

  /**
   * Writes out UnicodeProperties.java based on data fetched from unicode.org.
   *
   * @throws Exception If there is an error writing the output file.
   */
  private void emitUnicodeProperties(String skeletonFileName) throws Exception {
    StringBuilder builder = new StringBuilder();
    UnicodePropertiesSkeleton skeleton = new UnicodePropertiesSkeleton(skeletonFileName);
    skeleton.emitNext(builder); // Header
    emitClassComment(builder);
    // Class declaration and unicode versions static field declaration
    skeleton.emitNext(builder);
    emitUnicodeVersionsString(builder);
    // default unicode version static field declaration
    skeleton.emitNext(builder);
    emitDefaultUnicodeVersion(builder);
    // static vars and fixed method definitions, part 1
    skeleton.emitNext(builder);
    emitInitBody(builder);
    skeleton.emitNext(builder); // Fixed method definitions, part 2; etc.
    writeOutputFile(builder);
  }

  private void emitDefaultUnicodeVersion(StringBuilder builder) {
    builder.append("    \"").append(unicodeVersions.lastKey()).append("\";");
  }

  private void emitUnicodeVersionsString(StringBuilder builder) {
    builder.append("    \"");
    boolean isFirst = true;
    for (Map.Entry<String, UnicodeVersion> entry : unicodeVersions.entrySet()) {
      String majorMinorVersion = entry.getKey();
      if (isFirst) {
        isFirst = false;
      } else {
        builder.append(", ");
      }
      if (majorMinorVersion.indexOf(".0") == majorMinorVersion.length() - 2) {
        String majorVersion = majorMinorVersion.substring(0, majorMinorVersion.indexOf("."));
        builder.append(majorVersion).append(", ");
      }
      builder.append(entry).append(", ").append(entry.getValue().majorMinorUpdateVersion);
    }
    builder.append("\";");
  }

  private void emitVersionedUnicodeData() throws IOException {
    for (UnicodeVersion unicodeVersion : unicodeVersions.values()) {
      unicodeVersion.emitToDir(new File(outputDirectory, "data"));
    }
  }

  private void emitClassComment(StringBuilder builder) {
    builder
        .append("\n/**\n") // emit Class comment
        .append(" * This class was automatically generated by")
        .append(" jflex-unicode-maven-plugin based\n")
        .append(" * on data files downloaded from unicode.org.\n */");
  }

  private void emitInitBody(StringBuilder builder) {
    boolean isFirst = true;
    for (Map.Entry<String, UnicodeVersion> entry : unicodeVersions.entrySet()) {
      String majorMinorVersion = entry.getKey();
      if (isFirst) {
        builder.append("    if (");
        isFirst = false;
      } else {
        builder.append("    } else if (");
      }
      if (majorMinorVersion.indexOf(".0") == majorMinorVersion.length() - 2) {
        String majorVersion = majorMinorVersion.substring(0, majorMinorVersion.indexOf("."));
        builder.append("version.equals(\"").append(majorVersion).append("\") || ");
      }
      UnicodeVersion unicodeVersion = entry.getValue();
      String versionSuffix = unicodeVersion.getVersionSuffix();
      builder
          .append("version.equals(\"")
          .append(entry)
          .append("\") || version.equals(\"")
          .append(unicodeVersion.majorMinorUpdateVersion)
          .append("\")) {\n")
          .append("      bind(Unicode")
          .append(versionSuffix)
          .append(".propertyValues")
          .append(", Unicode")
          .append(versionSuffix)
          .append(".intervals")
          .append(", Unicode")
          .append(versionSuffix)
          .append(".propertyValueAliases")
          .append(",\n         Unicode")
          .append(versionSuffix)
          .append(".maximumCodePoint")
          .append(", Unicode")
          .append(versionSuffix)
          .append(".caselessMatchPartitions")
          .append(", Unicode")
          .append(versionSuffix)
          .append(".caselessMatchPartitionSize")
          .append(");\n");
    }
    builder
        .append("    } else {\n")
        .append("      throw new UnsupportedUnicodeVersionException();\n")
        .append("    }\n");
  }

  /**
   * Writes the contents of the given StringBuilder out to UnicodeProperties.java.
   *
   * @param builder What to write out
   * @throws IOException If there is an error writing out UnicodeProperties.java.
   */
  private void writeOutputFile(StringBuilder builder) throws IOException {
    PrintWriter writer = new PrintWriter(getOutputFile(), "UTF-8");
    writer.write(builder.toString());
    writer.flush();
    writer.close();
  }

  /**
   * Constructs and returns the name of the output file, based on the name of the output class
   * {@value #OUTPUT_CLASS_NAME}.
   *
   * @return The name of the output file.
   */
  private File getOutputFile() {
    return new File(outputDirectory, OUTPUT_CLASS_NAME + ".java");
  }
}
